/*! For license information please see chunk-QJ75ECAT.js.LICENSE.txt */
import{a as F}from"./chunk-O4MLFQKO.js";import{a as Z}from"./chunk-PFXLBIMV.js";import{a as X}from"./chunk-PSBTKXXJ.js";import{b as K,c as Q,d as U}from"./chunk-UJOKCDQH.js";import{d as H}from"./chunk-KYREMICR.js";import{a as y}from"./chunk-5ZFOKSDK.js";import{a as r,d as J,f as V}from"./chunk-7L2LUDC3.js";import{a as N}from"./chunk-77KFIUJG.js";import{a as b}from"./chunk-PX3QTMVS.js";import{e as R}from"./chunk-FE4HG5RY.js";var ii=new r(1,1,1),B=Math.cos,S=Math.sin;function v(i){let t=(i=i??V.EMPTY_OBJECT).radii??ii,e=i.innerRadii??t,o=i.minimumClock??0,n=i.maximumClock??N.TWO_PI,a=i.minimumCone??0,s=i.maximumCone??N.PI,m=Math.round(i.stackPartitions??10),u=Math.round(i.slicePartitions??8),f=Math.round(i.subdivisions??128);if(m<1)throw new b("options.stackPartitions cannot be less than 1");if(u<0)throw new b("options.slicePartitions cannot be less than 0");if(f<0)throw new b("options.subdivisions must be greater than or equal to zero.");if(R(i.offsetAttribute)&&i.offsetAttribute===F.TOP)throw new b("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=r.clone(t),this._innerRadii=r.clone(e),this._minimumClock=o,this._maximumClock=n,this._minimumCone=a,this._maximumCone=s,this._stackPartitions=m,this._slicePartitions=u,this._subdivisions=f,this._offsetAttribute=i.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}v.packedLength=2*r.packedLength+8,v.pack=function(i,t,e){if(!R(i))throw new b("value is required");if(!R(t))throw new b("array is required");return e=e??0,r.pack(i._radii,t,e),e+=r.packedLength,r.pack(i._innerRadii,t,e),e+=r.packedLength,t[e++]=i._minimumClock,t[e++]=i._maximumClock,t[e++]=i._minimumCone,t[e++]=i._maximumCone,t[e++]=i._stackPartitions,t[e++]=i._slicePartitions,t[e++]=i._subdivisions,t[e]=i._offsetAttribute??-1,t};var $=new r,G=new r,l={radii:$,innerRadii:G,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};v.unpack=function(i,t,e){if(!R(i))throw new b("array is required");t=t??0;let o=r.unpack(i,t,$);t+=r.packedLength;let n=r.unpack(i,t,G);t+=r.packedLength;let a=i[t++],s=i[t++],m=i[t++],u=i[t++],f=i[t++],c=i[t++],d=i[t++],h=i[t];return R(e)?(e._radii=r.clone(o,e._radii),e._innerRadii=r.clone(n,e._innerRadii),e._minimumClock=a,e._maximumClock=s,e._minimumCone=m,e._maximumCone=u,e._stackPartitions=f,e._slicePartitions=c,e._subdivisions=d,e._offsetAttribute=-1===h?void 0:h,e):(l.minimumClock=a,l.maximumClock=s,l.minimumCone=m,l.maximumCone=u,l.stackPartitions=f,l.slicePartitions=c,l.subdivisions=d,l.offsetAttribute=-1===h?void 0:h,new v(l))},v.createGeometry=function(i){let t=i._radii;if(t.x<=0||t.y<=0||t.z<=0)return;let e=i._innerRadii;if(e.x<=0||e.y<=0||e.z<=0)return;let r=i._minimumClock,o=i._maximumClock,n=i._minimumCone,a=i._maximumCone,s=i._subdivisions,m=J.fromCartesian3(t),u=i._slicePartitions+1,f=i._stackPartitions+1;u=Math.round(u*Math.abs(o-r)/N.TWO_PI),f=Math.round(f*Math.abs(a-n)/N.PI),u<2&&(u=2),f<2&&(f=2);let c=0,l=1,d=e.x!==t.x||e.y!==t.y||e.z!==t.z,h=!1,_=!1;d&&(l=2,n>0&&(h=!0,c+=u),a<Math.PI&&(_=!0,c+=u));let k,p,b,C,v=s*l*(f+u),w=new Float64Array(3*v),P=2*(v+c-(u+f)*l),x=Z.createTypedArray(v,P),A=0,M=new Array(f),g=new Array(f);for(k=0;k<f;k++)C=n+k*(a-n)/(f-1),M[k]=S(C),g[k]=B(C);let O=new Array(s),L=new Array(s);for(k=0;k<s;k++)b=r+k*(o-r)/(s-1),O[k]=S(b),L[k]=B(b);for(k=0;k<f;k++)for(p=0;p<s;p++)w[A++]=t.x*M[k]*L[p],w[A++]=t.y*M[k]*O[p],w[A++]=t.z*g[k];if(d)for(k=0;k<f;k++)for(p=0;p<s;p++)w[A++]=e.x*M[k]*L[p],w[A++]=e.y*M[k]*O[p],w[A++]=e.z*g[k];for(M.length=s,g.length=s,k=0;k<s;k++)C=n+k*(a-n)/(s-1),M[k]=S(C),g[k]=B(C);for(O.length=u,L.length=u,k=0;k<u;k++)b=r+k*(o-r)/(u-1),O[k]=S(b),L[k]=B(b);for(k=0;k<s;k++)for(p=0;p<u;p++)w[A++]=t.x*M[k]*L[p],w[A++]=t.y*M[k]*O[p],w[A++]=t.z*g[k];if(d)for(k=0;k<s;k++)for(p=0;p<u;p++)w[A++]=e.x*M[k]*L[p],w[A++]=e.y*M[k]*O[p],w[A++]=e.z*g[k];for(A=0,k=0;k<f*l;k++){let i=k*s;for(p=0;p<s-1;p++)x[A++]=i+p,x[A++]=i+p+1}let E=f*s*l;for(k=0;k<u;k++)for(p=0;p<s-1;p++)x[A++]=E+k+p*u,x[A++]=E+k+(p+1)*u;if(d)for(E=f*s*l+u*s,k=0;k<u;k++)for(p=0;p<s-1;p++)x[A++]=E+k+p*u,x[A++]=E+k+(p+1)*u;if(d){let i=f*s*l,t=i+s*u;if(h)for(k=0;k<u;k++)x[A++]=i+k,x[A++]=t+k;if(_)for(i+=s*u-u,t+=s*u-u,k=0;k<u;k++)x[A++]=i+k,x[A++]=t+k}let T=new X({position:new U({componentDatatype:y.DOUBLE,componentsPerAttribute:3,values:w})});if(R(i._offsetAttribute)){let t=w.length,e=i._offsetAttribute===F.NONE?0:1,r=new Uint8Array(t/3).fill(e);T.applyOffset=new U({componentDatatype:y.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return new Q({attributes:T,indices:x,primitiveType:K.LINES,boundingSphere:H.fromEllipsoid(m),offsetAttribute:i._offsetAttribute})};var Ci=v;export{Ci as a};