/*! For license information please see createVectorTilePolygons.js.LICENSE.txt */
import{a as R}from"./chunk-BOBXKID6.js";import{a as It}from"./chunk-65CN64EP.js";import{a as M}from"./chunk-UQ3ABODK.js";import{a as bt}from"./chunk-NYNUONZK.js";import"./chunk-C7EXJG2O.js";import"./chunk-LM5DN6BS.js";import"./chunk-S3NLG5WM.js";import"./chunk-AAOMPF7M.js";import{a as W}from"./chunk-PFXLBIMV.js";import"./chunk-KYREMICR.js";import{h as z}from"./chunk-VBRVI5XI.js";import"./chunk-5ZFOKSDK.js";import{a as o,b as nt,d as j}from"./chunk-7L2LUDC3.js";import{a as et}from"./chunk-77KFIUJG.js";import"./chunk-7W3OTLHS.js";import"./chunk-X52A3GF7.js";import"./chunk-PX3QTMVS.js";import{e as A}from"./chunk-FE4HG5RY.js";var kt=new o,Bt=new j,Nt=new z,E={min:void 0,max:void 0,indexBytesPerElement:void 0};function Pt(t){let e=new Float64Array(t),n=0;E.indexBytesPerElement=e[n++],E.min=e[n++],E.max=e[n++],o.unpack(e,n,kt),n+=o.packedLength,j.unpack(e,n,Bt),n+=j.packedLength,z.unpack(e,n,Nt)}function Tt(t){let e=t.length,n=0;for(let r=0;r<e;++r)n+=R.packedLength+3+t[r].batchIds.length;return n}function Ct(t,e,n){let r=e.length,a=2+r*M.packedLength+1+Tt(n),o=new Float64Array(a),i=0;o[i++]=t,o[i++]=r;for(let t=0;t<r;++t)M.pack(e[t],o,i),i+=M.packedLength;let s=n.length;o[i++]=s;for(let t=0;t<s;++t){let e=n[t];R.pack(e.color,o,i),i+=R.packedLength,o[i++]=e.offset,o[i++]=e.count;let r=e.batchIds,a=r.length;o[i++]=a;for(let t=0;t<a;++t)o[i++]=r[t]}return o}var yt=32767,wt=new o,Ht=new o,St=new o,Ut=new o,Ft=new o,Lt=new nt,Mt=new z;function Rt(t,e){let n;Pt(t.packedBuffer),n=2===E.indexBytesPerElement?new Uint16Array(t.indices):new Uint32Array(t.indices);let r=new Uint16Array(t.positions),a=new Uint32Array(t.counts),i=new Uint32Array(t.indexCounts),s=new Uint32Array(t.batchIds),f=new Uint32Array(t.batchTableColors),l=new Array(a.length),c=kt,h=Bt,u=Nt,m=E.min,p=E.max,d=t.minimumHeights,I=t.maximumHeights;A(d)&&A(I)&&(d=new Float32Array(d),I=new Float32Array(I));let g,k,w,b=r.length/2,y=r.subarray(0,b),N=r.subarray(b,2*b);bt.zigZagDeltaDecode(y,N);let L=new Float64Array(3*b);for(g=0;g<b;++g){let t=y[g],e=N[g],n=et.lerp(u.west,u.east,t/yt),r=et.lerp(u.south,u.north,e/yt),a=nt.fromRadians(n,r,0,Lt),i=h.cartographicToCartesian(a,wt);o.pack(i,L,3*g)}let x=a.length,j=new Array(x),T=new Array(x),F=0,O=0;for(g=0;g<x;++g)j[g]=F,T[g]=O,F+=a[g],O+=i[g];let U=new Float32Array(3*b*2),B=new Uint16Array(2*b),S=new Uint32Array(T.length),P=new Uint32Array(i.length),C=[],G={};for(g=0;g<x;++g)w=f[g],A(G[w])?(G[w].positionLength+=a[g],G[w].indexLength+=i[g],G[w].batchIds.push(g)):G[w]={positionLength:a[g],indexLength:i[g],offset:0,indexOffset:0,batchIds:[g]};let D,V=0,Y=0;for(w in G)if(G.hasOwnProperty(w)){D=G[w],D.offset=V,D.indexOffset=Y;let t=2*D.positionLength,e=2*D.indexLength+6*D.positionLength;V+=t,Y+=e,D.indexLength=e}let _=[];for(w in G)G.hasOwnProperty(w)&&(D=G[w],_.push({color:R.fromRgba(parseInt(w)),offset:D.indexOffset,count:D.indexLength,batchIds:D.batchIds}));for(g=0;g<x;++g){w=f[g],D=G[w];let t=D.offset,e=3*t,r=t,b=j[g],y=a[g],N=s[g],E=m,x=p;A(d)&&A(I)&&(E=d[g],x=I[g]);let F=Number.POSITIVE_INFINITY,O=Number.NEGATIVE_INFINITY,R=Number.POSITIVE_INFINITY,V=Number.NEGATIVE_INFINITY;for(k=0;k<y;++k){let t=o.unpack(L,3*b+3*k,wt);h.scaleToGeodeticSurface(t,t);let n=h.cartesianToCartographic(t,Lt),a=n.latitude,i=n.longitude;F=Math.min(a,F),O=Math.max(a,O),R=Math.min(i,R),V=Math.max(i,V);let s=h.geodeticSurfaceNormal(t,Ht),f=o.multiplyByScalar(s,E,St),l=o.add(t,f,Ut);f=o.multiplyByScalar(s,x,f);let u=o.add(t,f,Ft);o.subtract(u,c,u),o.subtract(l,c,l),o.pack(u,U,e),o.pack(l,U,e+3),B[r]=N,B[r+1]=N,e+=6,r+=2}u=Mt,u.west=R,u.east=V,u.south=F,u.north=O,l[g]=M.fromRectangle(u,m,p,h);let Y=D.indexOffset,_=T[g],H=i[g];for(S[g]=Y,k=0;k<H;k+=3){let e=n[_+k]-b,r=n[_+k+1]-b,a=n[_+k+2]-b;C[Y++]=2*e+t,C[Y++]=2*r+t,C[Y++]=2*a+t,C[Y++]=2*a+1+t,C[Y++]=2*r+1+t,C[Y++]=2*e+1+t}for(k=0;k<y;++k){let e=k,n=(k+1)%y;C[Y++]=2*e+1+t,C[Y++]=2*n+t,C[Y++]=2*e+t,C[Y++]=2*e+1+t,C[Y++]=2*n+1+t,C[Y++]=2*n+t}D.offset+=2*y,D.indexOffset=Y,P[g]=Y-S[g]}C=W.createTypedArray(U.length/3,C);let H=_.length;for(let t=0;t<H;++t){let e=_[t].batchIds,n=0,r=e.length;for(let t=0;t<r;++t)n+=P[e[t]];_[t].count=n}let K=Ct(2===C.BYTES_PER_ELEMENT?W.UNSIGNED_SHORT:W.UNSIGNED_INT,l,_);return e.push(U.buffer,C.buffer,S.buffer,P.buffer,B.buffer,K.buffer),{positions:U.buffer,indices:C.buffer,indexOffsets:S.buffer,indexCounts:P.buffer,batchIds:B.buffer,packedBuffer:K.buffer}}var Jt=It(Rt);export{Jt as default};