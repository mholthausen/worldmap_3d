/*! For license information please see chunk-ERAZHWPC.js.LICENSE.txt */
import{a as _}from"./chunk-GNAFTO6Q.js";import{a as te}from"./chunk-JATOGJGF.js";import{e as Z,h as me}from"./chunk-LYPPBP4Q.js";import{a as fe,b as j}from"./chunk-S7TTFAYA.js";import{a as e,b as ie,c as ee,e as O}from"./chunk-PYVDHCDQ.js";import{a as Q}from"./chunk-JMWWNZHX.js";import{a as se}from"./chunk-Z3SYNMQT.js";import{a as le}from"./chunk-4KGDZUZQ.js";import{e as $}from"./chunk-F3TINEFX.js";var Se={ROUNDED:0,MITERED:1,BEVELED:2},G=Object.freeze(Se),ue={};function P(e,t){if(!$(e))throw new le("identifier is required.");$(ue[e])||(ue[e]=!0,console.warn(se(t,e)))}P.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",P.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",P.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",P.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored";var he=P,w=[new e,new e],Te=new e,Be=new e,Ce=new e,ze=new e,Ae=new e,be=new e,Oe=new e,ve=new e,De=new e,I=new e,W=new e,R={},re=new ie;function je(e,t){let n=new Array(e.length);for(let r=0;r<e.length;r++){let o=e[r];re=t.cartesianToCartographic(o,re),n[r]=re.height,e[r]=t.scaleToGeodeticSurface(o,o)}return n}function ne(t,n,r,o){let a,l=t[0],i=t[1],c=e.angleBetween(l,i),s=Math.ceil(c/o),u=new Array(s);if(n===r){for(a=0;a<s;a++)u[a]=n;return u.push(r),u}let d=(r-n)/s;for(a=1;a<s;a++){let e=n+a*d;u[a]=e}return u[0]=n,u.push(r),u}var X=new e,Y=new e;function He(t,n,r,o){let a=new te(r,o),l=a.projectPointOntoPlane(e.add(r,t,X),X),i=a.projectPointOntoPlane(e.add(r,n,Y),Y),c=ee.angleBetween(l,i);return i.x*l.y-i.y*l.x>=0?-c:c}var Me=new e(-1,0,0),H=new j,Ve=new j,oe=new O,Ne=O.IDENTITY.clone(),Fe=new e,Ge=new fe,de=new e;function v(t,n,r,o,a,l,i,c){let s=Fe,u=Ge;H=me.eastNorthUpToFixedFrame(t,a,H),s=j.multiplyByPointAsVector(H,Me,s),s=e.normalize(s,s);let d=He(s,n,t,a);oe=O.fromRotationZ(d,oe),de.z=l,H=j.multiplyTransformation(H,j.fromRotationTranslation(oe,de,Ve),H);let w=Ne;w[0]=i;for(let t=0;t<c;t++)for(let t=0;t<r.length;t+=3)u=e.fromArray(r,t,u),u=O.multiplyByVector(w,u,u),u=j.multiplyByPoint(H,u,u),o.push(u.x,u.y,u.z);return o}var Ie=new e;function ce(t,n,r,o,a,l,i){for(let c=0;c<t.length;c+=3)o=v(e.fromArray(t,c,Ie),n,r,o,a,l[c/3],i,1);return o}function Le(e,t){let n=e.length,r=new Array(6*n),o=0,a=t.x+t.width/2,l=t.y+t.height/2,i=e[0];r[o++]=i.x-a,r[o++]=0,r[o++]=i.y-l;for(let t=1;t<n;t++){i=e[t];let n=i.x-a,c=i.y-l;r[o++]=n,r[o++]=0,r[o++]=c,r[o++]=n,r[o++]=0,r[o++]=c}return i=e[0],r[o++]=i.x-a,r[o++]=0,r[o++]=i.y-l,r}function ge(e,t){let n=e.length,r=new Array(3*n),o=0,a=t.x+t.width/2,l=t.y+t.height/2;for(let t=0;t<n;t++)r[o++]=e[t].x-a,r[o++]=0,r[o++]=e[t].y-l;return r}var ye=new Z,we=new e,pe=new O;function xe(t,n,r,o,a,l,i,c,s,u){let d,w,m,h=e.angleBetween(e.subtract(n,t,I),e.subtract(r,t,W)),g=o===G.BEVELED?0:Math.ceil(h/Q.toRadians(5));if(d=a?O.fromQuaternion(Z.fromAxisAngle(e.negate(t,I),h/(g+1),ye),pe):O.fromQuaternion(Z.fromAxisAngle(t,h/(g+1),ye),pe),n=e.clone(n,we),g>0){let r=u?2:1;for(let o=0;o<g;o++)n=O.multiplyByVector(d,n,n),w=e.subtract(n,t,I),w=e.normalize(w,w),a||(w=e.negate(w,w)),m=l.scaleToGeodeticSurface(n,W),i=v(m,w,c,i,l,s,1,r)}else w=e.subtract(n,t,I),w=e.normalize(w,w),a||(w=e.negate(w,w)),m=l.scaleToGeodeticSurface(n,W),i=v(m,w,c,i,l,s,1,1),r=e.clone(r,we),w=e.subtract(r,t,I),w=e.normalize(w,w),a||(w=e.negate(w,w)),m=l.scaleToGeodeticSurface(r,W),i=v(m,w,c,i,l,s,1,1);return i}R.removeDuplicatesFromShape=function(e){let t=e.length,n=[];for(let r=t-1,o=0;o<t;r=o++){let t=e[r],a=e[o];ee.equals(t,a)||n.push(a)}return n},R.angleIsGreaterThanPi=function(t,n,r,o){let a=new te(r,o),l=a.projectPointOntoPlane(e.add(r,t,X),X),i=a.projectPointOntoPlane(e.add(r,n,Y),Y);return i.x*l.y-i.y*l.x>=0};var qe=new e,Pe=new e;R.computePositions=function(t,n,r,o,a){let l=o._ellipsoid,i=je(t,l),c=o._granularity,s=o._cornerType,u=a?Le(n,r):ge(n,r),d=a?ge(n,r):void 0,m=r.height/2,h=r.width/2,g=t.length,y=[],f=a?[]:void 0,p=Te,x=Be,P=Ce,E=ze,b=Ae,O=be,j=Oe,T=ve,B=De,A=t[0],z=t[1];E=l.geodeticSurfaceNormal(A,E),p=e.subtract(z,A,p),p=e.normalize(p,p),T=e.cross(E,p,T),T=e.normalize(T,T);let S,D,H=i[0],N=i[1];a&&(f=v(A,T,d,f,l,H+m,1,1)),B=e.clone(A,B),A=z,x=e.negate(p,x);for(let n=1;n<g-1;n++){let r=a?2:1;if(z=t[n+1],A.equals(z)){he("Positions are too close and are considered equivalent with rounding error.");continue}p=e.subtract(z,A,p),p=e.normalize(p,p),P=e.add(p,x,P),P=e.normalize(P,P),E=l.geodeticSurfaceNormal(A,E);let o=e.multiplyByScalar(E,e.dot(p,E),qe);e.subtract(p,o,o),e.normalize(o,o);let d=e.multiplyByScalar(E,e.dot(x,E),Pe);if(e.subtract(x,d,d),e.normalize(d,d),Q.equalsEpsilon(Math.abs(e.dot(o,d)),1,Q.EPSILON7))y=v(B,T,u,y,l,H+m,1,1),B=A;else{P=e.cross(P,E,P),P=e.cross(E,P,P),P=e.normalize(P,P);let t=1/Math.max(.25,e.magnitude(e.cross(P,x,I))),n=R.angleIsGreaterThanPi(p,x,A,l);n?(b=e.add(A,e.multiplyByScalar(P,t*h,P),b),O=e.add(b,e.multiplyByScalar(T,h,O),O),w[0]=e.clone(B,w[0]),w[1]=e.clone(O,w[1]),S=ne(w,H+m,N+m,c),D=_.generateArc({positions:w,granularity:c,ellipsoid:l}),y=ce(D,T,u,y,l,S,1),T=e.cross(E,p,T),T=e.normalize(T,T),j=e.add(b,e.multiplyByScalar(T,h,j),j),s===G.ROUNDED||s===G.BEVELED?xe(b,O,j,s,n,l,y,u,N+m,a):(P=e.negate(P,P),y=v(A,P,u,y,l,N+m,t,r)),B=e.clone(j,B)):(b=e.add(A,e.multiplyByScalar(P,t*h,P),b),O=e.add(b,e.multiplyByScalar(T,-h,O),O),w[0]=e.clone(B,w[0]),w[1]=e.clone(O,w[1]),S=ne(w,H+m,N+m,c),D=_.generateArc({positions:w,granularity:c,ellipsoid:l}),y=ce(D,T,u,y,l,S,1),T=e.cross(E,p,T),T=e.normalize(T,T),j=e.add(b,e.multiplyByScalar(T,-h,j),j),s===G.ROUNDED||s===G.BEVELED?xe(b,O,j,s,n,l,y,u,N+m,a):y=v(A,P,u,y,l,N+m,t,r),B=e.clone(j,B)),x=e.negate(p,x)}H=N,N=i[n+1],A=z}w[0]=e.clone(B,w[0]),w[1]=e.clone(A,w[1]),S=ne(w,H+m,N+m,c),D=_.generateArc({positions:w,granularity:c,ellipsoid:l}),y=ce(D,T,u,y,l,S,1),a&&(f=v(A,T,d,f,l,N+m,1,1)),g=y.length;let F=a?g+f.length:g,V=new Float64Array(F);return V.set(y),a&&V.set(f,g),V};var lt=R;export{G as a,he as b,lt as c};