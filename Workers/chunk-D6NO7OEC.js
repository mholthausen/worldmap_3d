/*! For license information please see chunk-D6NO7OEC.js.LICENSE.txt */
import{a as _}from"./chunk-NXLA2DOI.js";import{a as G}from"./chunk-EOT3UPEC.js";import{b as B}from"./chunk-ZKNXHPHD.js";import{a as b}from"./chunk-W5ZMPE2M.js";import{b as L}from"./chunk-KDW4RGIR.js";import{a,b as D,c as z}from"./chunk-V624RX7A.js";import{a as E}from"./chunk-VZ2RFJ3P.js";import{a as C}from"./chunk-RKPKWH3Z.js";import{a as I}from"./chunk-BIYNNQRQ.js";import{e as T}from"./chunk-ZLUSVROX.js";var p={numberOfPoints:function(e,t,r){let n=a.distance(e,t);return Math.ceil(n/r)},numberOfPointsRhumbLine:function(e,t,a){let r=Math.pow(e.longitude-t.longitude,2)+Math.pow(e.latitude-t.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(r/(a*a))))}},V=new D;p.extractHeights=function(e,t){let a=e.length,r=new Array(a);for(let n=0;n<a;n++){let a=e[n];r[n]=t.cartesianToCartographic(a,V).height}return r};var Y=new L,W=new a,v=new a,F=new b(a.UNIT_X,0),H=new a,j=new b(a.UNIT_X,0),J=new a,K=new a,O=[];function q(e,t,a){let r,n=O;if(n.length=e,t===a){for(r=0;r<e;r++)n[r]=t;return n}let i=(a-t)/e;for(r=0;r<e;r++){let e=t+r*i;n[r]=e}return n}var x=new D,N=new D,S=new a,k=new a,Q=new a,M=new _,R=new G;function $(e,t,r,n,i,o,c,l){let s=n.scaleToGeodeticSurface(e,k),u=n.scaleToGeodeticSurface(t,Q),h=p.numberOfPoints(e,t,r),f=n.cartesianToCartographic(s,x),g=n.cartesianToCartographic(u,N),m=q(h,i,o);M.setEndPoints(f,g);let T=M.surfaceDistance/h,w=l;f.height=i;let d=n.cartographicToCartesian(f,S);a.pack(d,c,w),w+=3;for(let e=1;e<h;e++){let t=M.interpolateUsingSurfaceDistance(e*T,N);t.height=m[e],d=n.cartographicToCartesian(t,S),a.pack(d,c,w),w+=3}return w}function tt(e,t,r,n,i,o,c,l){let s=n.cartesianToCartographic(e,x),u=n.cartesianToCartographic(t,N),h=p.numberOfPointsRhumbLine(s,u,r);s.height=0,u.height=0;let f=q(h,i,o);R.ellipsoid.equals(n)||(R=new G(void 0,void 0,n)),R.setEndPoints(s,u);let g=R.surfaceDistance/h,m=l;s.height=i;let T=n.cartographicToCartesian(s,S);a.pack(T,c,m),m+=3;for(let e=1;e<h;e++){let t=R.interpolateUsingSurfaceDistance(e*g,N);t.height=f[e],T=n.cartographicToCartesian(t,S),a.pack(T,c,m),m+=3}return m}p.wrapLongitude=function(e,t){let r=[],n=[];if(T(e)&&e.length>0){t=C(t,L.IDENTITY);let i=L.inverseTransformation(t,Y),o=L.multiplyByPoint(i,a.ZERO,W),c=a.normalize(L.multiplyByPointAsVector(i,a.UNIT_Y,v),v),l=b.fromPointNormal(o,c,F),s=a.normalize(L.multiplyByPointAsVector(i,a.UNIT_X,H),H),u=b.fromPointNormal(o,s,j),h=1;r.push(a.clone(e[0]));let p=r[0],f=e.length;for(let t=1;t<f;++t){let i=e[t];if(b.getPointDistance(u,p)<0||b.getPointDistance(u,i)<0){let e=B.lineSegmentPlane(p,i,l,J);if(T(e)){let t=a.multiplyByScalar(c,5e-9,K);b.getPointDistance(l,p)<0&&a.negate(t,t),r.push(a.add(e,t,new a)),n.push(h+1),a.negate(t,t),r.push(a.add(e,t,new a)),h=1}}r.push(a.clone(e[t])),h++,p=i}n.push(h)}return{positions:r,lengths:n}},p.generateArc=function(e){T(e)||(e={});let t=e.positions;if(!T(t))throw new I("options.positions is required.");let r=t.length,n=C(e.ellipsoid,z.WGS84),i=C(e.height,0),o=Array.isArray(i);if(r<1)return[];if(1===r){let e=n.scaleToGeodeticSurface(t[0],k);if(i=o?i[0]:i,0!==i){let t=n.geodeticSurfaceNormal(e,S);a.multiplyByScalar(t,i,t),a.add(e,t,e)}return[e.x,e.y,e.z]}let c=e.minDistance;if(!T(c)){let t=C(e.granularity,E.RADIANS_PER_DEGREE);c=E.chordLength(t,n.maximumRadius)}let l,s=0;for(l=0;l<r-1;l++)s+=p.numberOfPoints(t[l],t[l+1],c);let u=3*(s+1),h=new Array(u),f=0;for(l=0;l<r-1;l++)f=$(t[l],t[l+1],c,n,o?i[l]:i,o?i[l+1]:i,h,f);O.length=0;let g=t[r-1],m=n.cartesianToCartographic(g,x);m.height=o?i[r-1]:i;let w=n.cartographicToCartesian(m,S);return a.pack(w,h,u-3),h};var U=new D,et=new D;p.generateRhumbArc=function(e){T(e)||(e={});let t=e.positions;if(!T(t))throw new I("options.positions is required.");let r=t.length,n=C(e.ellipsoid,z.WGS84),i=C(e.height,0),o=Array.isArray(i);if(r<1)return[];if(1===r){let e=n.scaleToGeodeticSurface(t[0],k);if(i=o?i[0]:i,0!==i){let t=n.geodeticSurfaceNormal(e,S);a.multiplyByScalar(t,i,t),a.add(e,t,e)}return[e.x,e.y,e.z]}let c,l,s=C(e.granularity,E.RADIANS_PER_DEGREE),u=0,h=n.cartesianToCartographic(t[0],U);for(c=0;c<r-1;c++)l=n.cartesianToCartographic(t[c+1],et),u+=p.numberOfPointsRhumbLine(h,l,s),h=D.clone(l,U);let f=3*(u+1),g=new Array(f),m=0;for(c=0;c<r-1;c++)m=tt(t[c],t[c+1],s,n,o?i[c]:i,o?i[c+1]:i,g,m);O.length=0;let w=t[r-1],d=n.cartesianToCartographic(w,x);d.height=o?i[r-1]:i;let R=n.cartographicToCartesian(d,S);return a.pack(R,g,f-3),g},p.generateCartesianArc=function(e){let t=p.generateArc(e),r=t.length/3,n=new Array(r);for(let e=0;e<r;e++)n[e]=a.unpack(t,3*e);return n},p.generateCartesianRhumbArc=function(e){let t=p.generateRhumbArc(e),r=t.length/3,n=new Array(r);for(let e=0;e<r;e++)n[e]=a.unpack(t,3*e);return n};var mt=p;export{mt as a};