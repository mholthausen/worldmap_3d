/*! For license information please see createPolylineGeometry.js.LICENSE.txt */
import{a as m}from"./chunk-GUUUD723.js";import{a as N}from"./chunk-AJBZ3ZYP.js";import{a as U}from"./chunk-GNAFTO6Q.js";import"./chunk-JXMT2ZQS.js";import{a as k}from"./chunk-GWMEMIDW.js";import{a as le}from"./chunk-EKKRJHD7.js";import"./chunk-KZVVSHMS.js";import"./chunk-EQAHH27B.js";import"./chunk-LWO5EUNN.js";import{a as se}from"./chunk-SPMRTIBU.js";import{a as ce}from"./chunk-U6MIZ4IC.js";import{a as ne,b as re,c as ie,d as O}from"./chunk-3G4OCZJT.js";import{d as oe}from"./chunk-LYPPBP4Q.js";import"./chunk-PCFGFNNQ.js";import"./chunk-V2SDNSQR.js";import"./chunk-S7TTFAYA.js";import{a as x}from"./chunk-TLYHKSDJ.js";import{a as p,d as u}from"./chunk-PYVDHCDQ.js";import{a as J}from"./chunk-JMWWNZHX.js";import"./chunk-DNO4OWAM.js";import"./chunk-XDVDNOI4.js";import{a as A}from"./chunk-Z3SYNMQT.js";import{a as V}from"./chunk-4KGDZUZQ.js";import{e as h}from"./chunk-F3TINEFX.js";var me=[];function Ae(e,t,r,o,n){let a=me;a.length=n;let i,s=r.red,l=r.green,p=r.blue,c=r.alpha,h=o.red,u=o.green,d=o.blue,k=o.alpha;if(m.equals(r,o)){for(i=0;i<n;i++)a[i]=m.clone(r);return a}let f=(h-s)/n,g=(u-l)/n,w=(d-p)/n,y=(k-c)/n;for(i=0;i<n;i++)a[i]=new m(s+i*f,l+i*g,p+i*w,c+i*y);return a}function q(e){let t=(e=A(e,A.EMPTY_OBJECT)).positions,r=e.colors,o=A(e.width,1),n=A(e.colorsPerVertex,!1);if(!h(t)||t.length<2)throw new V("At least two positions are required.");if("number"!=typeof o)throw new V("width must be a number");if(h(r)&&(n&&r.length<t.length||!n&&r.length<t.length-1))throw new V("colors has an invalid length.");this._positions=t,this._colors=r,this._width=o,this._colorsPerVertex=n,this._vertexFormat=k.clone(A(e.vertexFormat,k.DEFAULT)),this._arcType=A(e.arcType,N.GEODESIC),this._granularity=A(e.granularity,J.RADIANS_PER_DEGREE),this._ellipsoid=u.clone(A(e.ellipsoid,u.WGS84)),this._workerName="createPolylineGeometry";let a=1+t.length*p.packedLength;a+=h(r)?1+r.length*m.packedLength:1,this.packedLength=a+u.packedLength+k.packedLength+4}q.pack=function(e,t,r){if(!h(e))throw new V("value is required");if(!h(t))throw new V("array is required");r=A(r,0);let o,n=e._positions,a=n.length;for(t[r++]=a,o=0;o<a;++o,r+=p.packedLength)p.pack(n[o],t,r);let i=e._colors;for(a=h(i)?i.length:0,t[r++]=a,o=0;o<a;++o,r+=m.packedLength)m.pack(i[o],t,r);return u.pack(e._ellipsoid,t,r),r+=u.packedLength,k.pack(e._vertexFormat,t,r),r+=k.packedLength,t[r++]=e._width,t[r++]=e._colorsPerVertex?1:0,t[r++]=e._arcType,t[r]=e._granularity,t};var de=u.clone(u.UNIT_SPHERE),ue=new k,S={positions:void 0,colors:void 0,ellipsoid:de,vertexFormat:ue,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};q.unpack=function(e,t,r){if(!h(e))throw new V("array is required");t=A(t,0);let o,n=e[t++],a=new Array(n);for(o=0;o<n;++o,t+=p.packedLength)a[o]=p.unpack(e,t);n=e[t++];let i=n>0?new Array(n):void 0;for(o=0;o<n;++o,t+=m.packedLength)i[o]=m.unpack(e,t);let s=u.unpack(e,t,de);t+=u.packedLength;let l=k.unpack(e,t,ue);t+=k.packedLength;let c=e[t++],d=1===e[t++],f=e[t++],g=e[t];return h(r)?(r._positions=a,r._colors=i,r._ellipsoid=u.clone(s,r._ellipsoid),r._vertexFormat=k.clone(l,r._vertexFormat),r._width=c,r._colorsPerVertex=d,r._arcType=f,r._granularity=g,r):(S.positions=a,S.colors=i,S.width=c,S.colorsPerVertex=d,S.arcType=f,S.granularity=g,new q(S))};var pe=new p,ae=new p,fe=new p,he=new p;q.createGeometry=function(e){let t,r,o,n=e._width,a=e._vertexFormat,i=e._colors,s=e._colorsPerVertex,l=e._arcType,c=e._granularity,u=e._ellipsoid,d=[],k=le(e._positions,p.equalsEpsilon,!1,d);if(h(i)&&d.length>0){let e=0,t=d[0];i=i.filter((function(r,o){let n=!1;return n=s?o===t||0===o&&1===t:o+1===t,!n||(e++,t=d[e],!1)}))}let f=k.length;if(f<2||n<=0)return;if(l===N.GEODESIC||l===N.RHUMB){let e,o;l===N.GEODESIC?(e=J.chordLength(c,u.maximumRadius),o=U.numberOfPoints):(e=c,o=U.numberOfPointsRhumbLine);let n=U.extractHeights(k,u);if(h(i)){let n=1;for(t=0;t<f-1;++t)n+=o(k[t],k[t+1],e);let a=new Array(n),l=0;for(t=0;t<f-1;++t){let p=k[t],c=k[t+1],h=i[t],u=o(p,c,e);if(s&&t<n){let e=Ae(p,c,h,i[t+1],u),o=e.length;for(r=0;r<o;++r)a[l++]=e[r]}else for(r=0;r<u;++r)a[l++]=m.clone(h)}a[l]=m.clone(i[i.length-1]),i=a,me.length=0}k=l===N.GEODESIC?U.generateCartesianArc({positions:k,minDistance:e,ellipsoid:u,height:n}):U.generateCartesianRhumbArc({positions:k,granularity:e,ellipsoid:u,height:n})}f=k.length;let g,w=4*f-4,y=new Float64Array(3*w),A=new Float64Array(3*w),_=new Float64Array(3*w),v=new Float32Array(2*w),T=a.st?new Float32Array(2*w):void 0,E=h(i)?new Uint8Array(4*w):void 0,P=0,D=0,S=0,L=0;for(r=0;r<f;++r){let e,t;0===r?(g=pe,p.subtract(k[0],k[1],g),p.add(k[0],g,g)):g=k[r-1],p.clone(g,fe),p.clone(k[r],ae),r===f-1?(g=pe,p.subtract(k[f-1],k[f-2],g),p.add(k[f-1],g,g)):g=k[r+1],p.clone(g,he),h(E)&&(e=0===r||s?i[r]:i[r-1],r!==f-1&&(t=i[r]));let l=r===f-1?2:4;for(o=0===r?2:0;o<l;++o){p.pack(ae,y,P),p.pack(fe,A,P),p.pack(he,_,P),P+=3;let i=o-2<0?-1:1;if(v[D++]=o%2*2-1,v[D++]=i*n,a.st&&(T[S++]=r/(f-1),T[S++]=Math.max(v[D-2],0)),h(E)){let r=o<2?e:t;E[L++]=m.floatToByte(r.red),E[L++]=m.floatToByte(r.green),E[L++]=m.floatToByte(r.blue),E[L++]=m.floatToByte(r.alpha)}}}let j=new ce;j.position=new O({componentDatatype:x.DOUBLE,componentsPerAttribute:3,values:y}),j.prevPosition=new O({componentDatatype:x.DOUBLE,componentsPerAttribute:3,values:A}),j.nextPosition=new O({componentDatatype:x.DOUBLE,componentsPerAttribute:3,values:_}),j.expandAndWidth=new O({componentDatatype:x.FLOAT,componentsPerAttribute:2,values:v}),a.st&&(j.st=new O({componentDatatype:x.FLOAT,componentsPerAttribute:2,values:T})),h(E)&&(j.color=new O({componentDatatype:x.UNSIGNED_BYTE,componentsPerAttribute:4,values:E,normalize:!0}));let b=se.createTypedArray(w,6*f-6),F=0,V=0,G=f-1;for(r=0;r<G;++r)b[V++]=F,b[V++]=F+2,b[V++]=F+1,b[V++]=F+1,b[V++]=F+2,b[V++]=F+3,F+=4;return new ie({attributes:j,indices:b,primitiveType:re.TRIANGLES,boundingSphere:oe.fromPoints(k),geometryType:ne.POLYLINES})};var Q=q;function ge(e,t){return h(t)&&(e=Q.unpack(e,t)),e._ellipsoid=u.clone(e._ellipsoid),Q.createGeometry(e)}var He=ge;export{He as default};