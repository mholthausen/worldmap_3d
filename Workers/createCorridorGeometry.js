define(["./GeometryOffsetAttribute-03006e80","./arrayRemoveDuplicates-707c233c","./Transforms-1142ce48","./Cartesian2-08065eec","./Check-be2d5acb","./ComponentDatatype-a867ddaa","./PolylineVolumeGeometryLibrary-0e3fa363","./CorridorGeometryLibrary-0fba23cb","./when-ad3237a0","./GeometryAttribute-da891979","./GeometryAttributes-27dc652d","./IndexDatatype-9504f550","./Math-5ca9b250","./PolygonPipeline-ac773b7c","./VertexFormat-fc4fc84a","./combine-1510933d","./RuntimeError-767bd866","./WebGLConstants-1c8239cc","./EllipsoidTangentPlane-f8b1fc8b","./AxisAlignedBoundingBox-718a9087","./IntersectionTests-75083888","./Plane-bb88dd7e","./PolylinePipeline-05927ee2","./EllipsoidGeodesic-dc284f08","./EllipsoidRhumbLine-4a6ed5de"],(function(t,e,r,a,i,o,n,s,l,d,u,m,y,c,f,p,h,g,C,b,A,v,_,w,T){"use strict";var G=new a.Cartesian3,E=new a.Cartesian3,V=new a.Cartesian3,F=new a.Cartesian3,L=new a.Cartesian3,x=new a.Cartesian3,P=new a.Cartesian3,N=new a.Cartesian3;function D(t,e){for(var r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function M(t,e,r,i,o,n){var l=t.normals,d=t.tangents,u=t.bitangents;t=a.Cartesian3.normalize(a.Cartesian3.cross(r,e,P),P),n.normal&&s.CorridorGeometryLibrary.addAttribute(l,e,i,o),n.tangent&&s.CorridorGeometryLibrary.addAttribute(d,t,i,o),n.bitangent&&s.CorridorGeometryLibrary.addAttribute(u,r,i,o)}function O(t,e,r){var i,n=t.positions,c=t.corners,f=t.endPositions,p=t.lefts,h=t.normals,g=new u.GeometryAttributes,C=0,b=0,A=0;for(K=0;K<n.length;K+=2)C+=i=n[K].length-3,A+=2*i,b+=n[K+1].length-3;for(C+=3,b+=3,K=0;K<c.length;K++){var v=c[K],_=c[K].leftPositions;l.defined(_)?C+=i=_.length:b+=i=c[K].rightPositions.length,A+=i}var w,T=l.defined(f);T&&(C+=w=f[0].length-3,b+=w,A+=6*(w/=3)),t=C+b;var L,D,O,I,S=new Float64Array(t),R={normals:e.normal?new Float32Array(t):void 0,tangents:e.tangent?new Float32Array(t):void 0,bitangents:e.bitangent?new Float32Array(t):void 0},k=0,H=t-1,z=G,B=E,U=w/2,Y=m.IndexDatatype.createTypedArray(t/3,A),W=0;if(T)for(var q=V,J=F,j=f[0],K=(z=a.Cartesian3.fromArray(h,0,z),B=a.Cartesian3.fromArray(p,0,B),0);K<U;K++)q=a.Cartesian3.fromArray(j,3*(U-1-K),q),J=a.Cartesian3.fromArray(j,3*(U+K),J),s.CorridorGeometryLibrary.addAttribute(S,J,k),s.CorridorGeometryLibrary.addAttribute(S,q,void 0,H),M(R,z,B,k,H,e),I=1+(D=k/3),O=(L=(H-2)/3)-1,Y[W++]=L,Y[W++]=D,Y[W++]=O,Y[W++]=O,Y[W++]=D,Y[W++]=I,k+=3,H-=3;var Q,X,Z=0,$=0,tt=n[Z++],et=n[Z++];for(S.set(tt,k),S.set(et,H-et.length+1),B=a.Cartesian3.fromArray(p,$,B),i=et.length-3,K=0;K<i;K+=3)Q=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(tt,K,P),P),X=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(et,i-K,N),N),M(R,z=a.Cartesian3.normalize(a.Cartesian3.add(Q,X,z),z),B,k,H,e),I=1+(D=k/3),O=(L=(H-2)/3)-1,Y[W++]=L,Y[W++]=D,Y[W++]=O,Y[W++]=O,Y[W++]=D,Y[W++]=I,k+=3,H-=3;for(Q=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(tt,i,P),P),X=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(et,i,N),N),z=a.Cartesian3.normalize(a.Cartesian3.add(Q,X,z),z),$+=3,K=0;K<c.length;K++){var rt,at,it,ot=(v=c[K]).leftPositions,nt=v.rightPositions,st=x,lt=V,dt=F;if(z=a.Cartesian3.fromArray(h,$,z),l.defined(ot)){for(M(R,z,B,void 0,H,e),H-=3,at=I,it=O,rt=0;rt<ot.length/3;rt++)st=a.Cartesian3.fromArray(ot,3*rt,st),Y[W++]=at,Y[W++]=it-rt-1,Y[W++]=it-rt,s.CorridorGeometryLibrary.addAttribute(S,st,void 0,H),lt=a.Cartesian3.fromArray(S,3*(it-rt-1),lt),dt=a.Cartesian3.fromArray(S,3*at,dt),M(R,z,B=a.Cartesian3.normalize(a.Cartesian3.subtract(lt,dt,B),B),void 0,H,e),H-=3;st=a.Cartesian3.fromArray(S,3*at,st),lt=a.Cartesian3.subtract(a.Cartesian3.fromArray(S,3*it,lt),st,lt),dt=a.Cartesian3.subtract(a.Cartesian3.fromArray(S,3*(it-rt),dt),st,dt),M(R,z,B=a.Cartesian3.normalize(a.Cartesian3.add(lt,dt,B),B),k,void 0,e),k+=3}else{for(M(R,z,B,k,void 0,e),k+=3,at=O,it=I,rt=0;rt<nt.length/3;rt++)st=a.Cartesian3.fromArray(nt,3*rt,st),Y[W++]=at,Y[W++]=it+rt,Y[W++]=it+rt+1,s.CorridorGeometryLibrary.addAttribute(S,st,k),lt=a.Cartesian3.fromArray(S,3*at,lt),dt=a.Cartesian3.fromArray(S,3*(it+rt),dt),M(R,z,B=a.Cartesian3.normalize(a.Cartesian3.subtract(lt,dt,B),B),k,void 0,e),k+=3;st=a.Cartesian3.fromArray(S,3*at,st),lt=a.Cartesian3.subtract(a.Cartesian3.fromArray(S,3*(it+rt),lt),st,lt),dt=a.Cartesian3.subtract(a.Cartesian3.fromArray(S,3*it,dt),st,dt),M(R,z,B=a.Cartesian3.normalize(a.Cartesian3.negate(a.Cartesian3.add(dt,lt,B),B),B),void 0,H,e),H-=3}for(tt=n[Z++],et=n[Z++],tt.splice(0,3),et.splice(et.length-3,3),S.set(tt,k),S.set(et,H-et.length+1),i=et.length-3,$+=3,B=a.Cartesian3.fromArray(p,$,B),rt=0;rt<et.length;rt+=3)Q=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(tt,rt,P),P),X=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(et,i-rt,N),N),M(R,z=a.Cartesian3.normalize(a.Cartesian3.add(Q,X,z),z),B,k,H,e),D=(I=k/3)-1,Y[W++]=L=1+(O=(H-2)/3),Y[W++]=D,Y[W++]=O,Y[W++]=O,Y[W++]=D,Y[W++]=I,k+=3,H-=3;k-=3,H+=3}if(M(R,z=a.Cartesian3.fromArray(h,h.length-3,z),B,k,H,e),T){k+=3,H-=3,q=V,J=F;var ut=f[1];for(K=0;K<U;K++)q=a.Cartesian3.fromArray(ut,3*(w-K-1),q),J=a.Cartesian3.fromArray(ut,3*K,J),s.CorridorGeometryLibrary.addAttribute(S,q,void 0,H),s.CorridorGeometryLibrary.addAttribute(S,J,k),M(R,z,B,k,H,e),D=(I=k/3)-1,Y[W++]=L=1+(O=(H-2)/3),Y[W++]=D,Y[W++]=O,Y[W++]=O,Y[W++]=D,Y[W++]=I,k+=3,H-=3}if(g.position=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:S}),e.st){var mt=new Float32Array(t/3*2),yt=0;if(T){C/=3,b/=3;var ct,ft=Math.PI/(w+1),pt=1/(C-w+1),ht=1/(b-w+1),gt=w/2;for(K=1+gt;K<w+1;K++)ct=y.CesiumMath.PI_OVER_TWO+ft*K,mt[yt++]=ht*(1+Math.cos(ct)),mt[yt++]=.5*(1+Math.sin(ct));for(K=1;K<b-w+1;K++)mt[yt++]=K*ht,mt[yt++]=0;for(K=w;gt<K;K--)ct=y.CesiumMath.PI_OVER_TWO-K*ft,mt[yt++]=1-ht*(1+Math.cos(ct)),mt[yt++]=.5*(1+Math.sin(ct));for(K=gt;0<K;K--)ct=y.CesiumMath.PI_OVER_TWO-ft*K,mt[yt++]=1-pt*(1+Math.cos(ct)),mt[yt++]=.5*(1+Math.sin(ct));for(K=C-w;0<K;K--)mt[yt++]=K*pt,mt[yt++]=1;for(K=1;K<1+gt;K++)ct=y.CesiumMath.PI_OVER_TWO+ft*K,mt[yt++]=pt*(1+Math.cos(ct)),mt[yt++]=.5*(1+Math.sin(ct))}else{for(pt=1/((C/=3)-1),ht=1/((b/=3)-1),K=0;K<b;K++)mt[yt++]=K*ht,mt[yt++]=0;for(K=C;0<K;K--)mt[yt++]=(K-1)*pt,mt[yt++]=1}g.st=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:mt})}return e.normal&&(g.normal=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R.normals})),e.tangent&&(g.tangent=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R.tangents})),e.bitangent&&(g.bitangent=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R.bitangents})),{attributes:g,indices:Y}}function I(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(var a=3;a<t.length;a+=3){var i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}var S=new a.Cartesian3,R=new a.Cartesian3,k=new a.Cartographic;function H(t,e,r,i,o,n){var s=a.Cartesian3.subtract(e,t,S);a.Cartesian3.normalize(s,s);var l=r.geodeticSurfaceNormal(t,R),d=a.Cartesian3.cross(s,l,S);a.Cartesian3.multiplyByScalar(d,i,d);var u=o.latitude,m=o.longitude;e=n.latitude,s=n.longitude,a.Cartesian3.add(t,d,R),r.cartesianToCartographic(R,k),l=k.latitude,i=k.longitude,u=Math.min(u,l),m=Math.min(m,i),e=Math.max(e,l),s=Math.max(s,i),a.Cartesian3.subtract(t,d,R),r.cartesianToCartographic(R,k),l=k.latitude,i=k.longitude,u=Math.min(u,l),m=Math.min(m,i),e=Math.max(e,l),s=Math.max(s,i),o.latitude=u,o.longitude=m,n.latitude=e,n.longitude=s}var z=new a.Cartesian3,B=new a.Cartesian3,U=new a.Cartographic,Y=new a.Cartographic;function W(t,r,i,o,s){t=D(t,r);var d=e.arrayRemoveDuplicates(t,a.Cartesian3.equalsEpsilon),u=d.length;if(u<2||i<=0)return new a.Rectangle;var m,y,c=.5*i;U.latitude=Number.POSITIVE_INFINITY,U.longitude=Number.POSITIVE_INFINITY,Y.latitude=Number.NEGATIVE_INFINITY,Y.longitude=Number.NEGATIVE_INFINITY,o===n.CornerType.ROUNDED&&(p=d[0],a.Cartesian3.subtract(p,d[1],z),a.Cartesian3.normalize(z,z),a.Cartesian3.multiplyByScalar(z,c,z),a.Cartesian3.add(p,z,B),r.cartesianToCartographic(B,k),m=k.latitude,y=k.longitude,U.latitude=Math.min(U.latitude,m),U.longitude=Math.min(U.longitude,y),Y.latitude=Math.max(Y.latitude,m),Y.longitude=Math.max(Y.longitude,y));for(var f=0;f<u-1;++f)H(d[f],d[f+1],r,c,U,Y);var p=d[u-1];return a.Cartesian3.subtract(p,d[u-2],z),a.Cartesian3.normalize(z,z),a.Cartesian3.multiplyByScalar(z,c,z),a.Cartesian3.add(p,z,B),H(p,B,r,c,U,Y),o===n.CornerType.ROUNDED&&(r.cartesianToCartographic(B,k),m=k.latitude,y=k.longitude,U.latitude=Math.min(U.latitude,m),U.longitude=Math.min(U.longitude,y),Y.latitude=Math.max(Y.latitude,m),Y.longitude=Math.max(Y.longitude,y)),(s=l.defined(s)?s:new a.Rectangle).north=Y.latitude,s.south=U.latitude,s.east=Y.longitude,s.west=U.longitude,s}function q(t){var e=(t=l.defaultValue(t,l.defaultValue.EMPTY_OBJECT)).positions,r=t.width,i=l.defaultValue(t.height,0),o=l.defaultValue(t.extrudedHeight,i);this._positions=e,this._ellipsoid=a.Ellipsoid.clone(l.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84)),this._vertexFormat=f.VertexFormat.clone(l.defaultValue(t.vertexFormat,f.VertexFormat.DEFAULT)),this._width=r,this._height=Math.max(i,o),this._extrudedHeight=Math.min(i,o),this._cornerType=l.defaultValue(t.cornerType,n.CornerType.ROUNDED),this._granularity=l.defaultValue(t.granularity,y.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=l.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*a.Cartesian3.packedLength+a.Ellipsoid.packedLength+f.VertexFormat.packedLength+7}q.pack=function(t,e,r){r=l.defaultValue(r,0);var i=t._positions,o=i.length;e[r++]=o;for(var n=0;n<o;++n,r+=a.Cartesian3.packedLength)a.Cartesian3.pack(i[n],e,r);return a.Ellipsoid.pack(t._ellipsoid,e,r),r+=a.Ellipsoid.packedLength,f.VertexFormat.pack(t._vertexFormat,e,r),r+=f.VertexFormat.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=t._shadowVolume?1:0,e[r]=l.defaultValue(t._offsetAttribute,-1),e};var J=a.Ellipsoid.clone(a.Ellipsoid.UNIT_SPHERE),j=new f.VertexFormat,K={positions:void 0,ellipsoid:J,vertexFormat:j,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return q.unpack=function(t,e,r){e=l.defaultValue(e,0);for(var i=t[e++],o=new Array(i),n=0;n<i;++n,e+=a.Cartesian3.packedLength)o[n]=a.Cartesian3.unpack(t,e);var s=a.Ellipsoid.unpack(t,e,J);e+=a.Ellipsoid.packedLength;var d=f.VertexFormat.unpack(t,e,j);e+=f.VertexFormat.packedLength;var u=t[e++],m=t[e++],y=t[e++],c=t[e++],p=t[e++],h=1===t[e++],g=t[e];return l.defined(r)?(r._positions=o,r._ellipsoid=a.Ellipsoid.clone(s,r._ellipsoid),r._vertexFormat=f.VertexFormat.clone(d,r._vertexFormat),r._width=u,r._height=m,r._extrudedHeight=y,r._cornerType=c,r._granularity=p,r._shadowVolume=h,r._offsetAttribute=-1===g?void 0:g,r):(K.positions=o,K.width=u,K.height=m,K.extrudedHeight=y,K.cornerType=c,K.granularity=p,K.shadowVolume=h,K.offsetAttribute=-1===g?void 0:g,new q(K))},q.computeRectangle=function(t,e){var r=(t=l.defaultValue(t,l.defaultValue.EMPTY_OBJECT)).positions,i=t.width;return W(r,l.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84),i,l.defaultValue(t.cornerType,n.CornerType.ROUNDED),e)},q.createGeometry=function(i){var n=i._positions,u=i._width,p=i._ellipsoid,h=(n=D(n,p),e.arrayRemoveDuplicates(n,a.Cartesian3.equalsEpsilon));if(!(h.length<2||u<=0)){var g,C=i._height,b=i._extrudedHeight,A=!y.CesiumMath.equalsEpsilon(C,b,0,y.CesiumMath.EPSILON2);n=i._vertexFormat,u={ellipsoid:p,positions:h,width:u,cornerType:i._cornerType,granularity:i._granularity,saveAttributes:!0},A?(u.height=C,u.extrudedHeight=b,u.shadowVolume=i._shadowVolume,u.offsetAttribute=i._offsetAttribute,g=function(e,r){var i=new f.VertexFormat({position:r.position,normal:r.normal||r.bitangent||e.shadowVolume,tangent:r.tangent,bitangent:r.normal||r.bitangent,st:r.st}),n=e.ellipsoid,u=O(s.CorridorGeometryLibrary.computePositions(e),i,n),y=e.height,p=e.extrudedHeight,h=u.attributes,g=u.indices,C=h.position.values,b=C.length,A=new Float64Array(6*b);(i=new Float64Array(b)).set(C),u=new Float64Array(4*b),u=I(C=c.PolygonPipeline.scaleToGeodeticHeight(C,y,n),0,u),u=I(i=c.PolygonPipeline.scaleToGeodeticHeight(i,p,n),2*b,u),A.set(C),A.set(i,b),A.set(u,2*b),h.position.values=A,h=function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;var r,i=t.position.values;(e.normal||e.bitangent)&&(r=t.normal.values,u=t.bitangent.values);var o=t.position.values.length/18,n=3*o,l=2*o,d=2*n;if(e.normal||e.bitangent||e.tangent){for(var u,m=e.normal?new Float32Array(6*n):void 0,y=e.tangent?new Float32Array(6*n):void 0,c=e.bitangent?new Float32Array(6*n):void 0,f=G,p=E,h=V,g=F,C=L,b=x,A=d,v=0;v<n;v+=3){var _=A+d;f=a.Cartesian3.fromArray(i,v,f),p=a.Cartesian3.fromArray(i,v+n,p),h=a.Cartesian3.fromArray(i,(v+3)%n,h),p=a.Cartesian3.subtract(p,f,p),h=a.Cartesian3.subtract(h,f,h),g=a.Cartesian3.normalize(a.Cartesian3.cross(p,h,g),g),e.normal&&(s.CorridorGeometryLibrary.addAttribute(m,g,_),s.CorridorGeometryLibrary.addAttribute(m,g,_+3),s.CorridorGeometryLibrary.addAttribute(m,g,A),s.CorridorGeometryLibrary.addAttribute(m,g,A+3)),(e.tangent||e.bitangent)&&(b=a.Cartesian3.fromArray(r,v,b),e.bitangent&&(s.CorridorGeometryLibrary.addAttribute(c,b,_),s.CorridorGeometryLibrary.addAttribute(c,b,_+3),s.CorridorGeometryLibrary.addAttribute(c,b,A),s.CorridorGeometryLibrary.addAttribute(c,b,A+3)),e.tangent&&(C=a.Cartesian3.normalize(a.Cartesian3.cross(b,g,C),C),s.CorridorGeometryLibrary.addAttribute(y,C,_),s.CorridorGeometryLibrary.addAttribute(y,C,_+3),s.CorridorGeometryLibrary.addAttribute(y,C,A),s.CorridorGeometryLibrary.addAttribute(y,C,A+3))),A+=6}if(e.normal){for(m.set(r),v=0;v<n;v+=3)m[v+n]=-r[v],m[v+n+1]=-r[v+1],m[v+n+2]=-r[v+2];t.normal.values=m}else t.normal=void 0;e.bitangent?(c.set(u),c.set(u,n),t.bitangent.values=c):t.bitangent=void 0,e.tangent&&(u=t.tangent.values,y.set(u),y.set(u,n),t.tangent.values=y)}if(e.st){var w=t.st.values,T=new Float32Array(6*l);T.set(w),T.set(w,l);for(var P=2*l,N=0;N<2;N++){for(T[P++]=w[0],T[P++]=w[1],v=2;v<l;v+=2){var D=w[v],M=w[v+1];T[P++]=D,T[P++]=M,T[P++]=D,T[P++]=M}T[P++]=w[0],T[P++]=w[1]}t.st.values=T}return t}(h,r);var v=b/3;if(e.shadowVolume){for(var _=h.normal.values,w=(b=_.length,u=new Float32Array(6*b),0);w<b;w++)_[w]=-_[w];u.set(_,b),u=I(_,4*b,u),h.extrudeDirection=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:u}),r.normal||(h.normal=void 0)}l.defined(e.offsetAttribute)&&(r=new Uint8Array(6*v),r=e.offsetAttribute===t.GeometryOffsetAttribute.TOP?(r=t.arrayFill(r,1,0,v),t.arrayFill(r,1,2*v,4*v)):(e=e.offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1,t.arrayFill(r,e)),h.applyOffset=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r}));var T=g.length,P=v+v,N=m.IndexDatatype.createTypedArray(A.length/3,2*T+3*P);N.set(g);var D,M,S,R,k=T;for(w=0;w<T;w+=3){var H=g[w],z=g[w+1],B=g[w+2];N[k++]=B+v,N[k++]=z+v,N[k++]=H+v}for(w=0;w<P;w+=2)S=(D=w+P)+1,R=(M=D+P)+1,N[k++]=D,N[k++]=M,N[k++]=S,N[k++]=S,N[k++]=M,N[k++]=R;return{attributes:h,indices:N}}(u,n)):((g=O(s.CorridorGeometryLibrary.computePositions(u),n,p)).attributes.position.values=c.PolygonPipeline.scaleToGeodeticHeight(g.attributes.position.values,C,p),l.defined(i._offsetAttribute)&&(v=i._offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1,_=g.attributes.position.values.length,_=new Uint8Array(_/3),t.arrayFill(_,v),g.attributes.applyOffset=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:_})));var v=g.attributes,_=r.BoundingSphere.fromVertices(v.position.values,void 0,3);return n.position||(g.attributes.position.values=void 0),new d.Geometry({attributes:v,indices:g.indices,primitiveType:d.PrimitiveType.TRIANGLES,boundingSphere:_,offsetAttribute:i._offsetAttribute})}},q.createShadowVolume=function(t,e,r){var a=t._granularity,i=t._ellipsoid;return e=e(a,i),r=r(a,i),new q({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:e,height:r,vertexFormat:f.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(q.prototype,{rectangle:{get:function(){return l.defined(this._rectangle)||(this._rectangle=W(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return(t=l.defined(e)?q.unpack(t,e):t)._ellipsoid=a.Ellipsoid.clone(t._ellipsoid),q.createGeometry(t)}}));